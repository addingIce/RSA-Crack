一、未找到
    ===当e过小时，对小的m，可能出现 m^e<m 的情况，此时 c=n^e mod m = n^e,
       即未取模，由c直接开e次方就可求出明文m这种情况
    ===代码为iroot.py

二、公共模数攻击
    ===Frame0 和 Frame4 使用相同的模数N
    ===破解代码为 sameN.py
    ===解出明文 m = 'My secre'

    ===目前破解的Frame有0,4

三、低加密指数攻击
    ===Frame7、11、15使用相同的e=0x03，但解不出明文
    ===Frame3、8、12、16、20使用相同的e=0x05，可以解出明文
    ===破解代码为 low_encrypt_e.py
    ===解出明文 m = 't is a f'

    ===目前破解的Frame有0,3,4,8,12,16,20

四、如果在两次公钥的加密过程中使用的n1和n2具有相同的素因子，那么可以利用欧几里得算法
直接将n1和n2分解。通过欧几里得算法可以直接求出n1和n2的最大公约数p:
(n1,n2)=p 可以得出：n1=p*q1 n2=p*q2
    ===Frame1 和 Frame18 含有含有相同因子p的N
    ===破解代码为 N_with_same_p.py
    ===解出Frame1明文为  m = '. Imagin'
           Frame18明文为 m = 'm A to B'

    ===目前破解的Frame有0,1,3,4,8,12,16,18,20

五、在p，q的取值差异过大，或者p，q的取值过于相近的时候，Pollard rho方法可以很快将n分解成功
    ===分解得到Frame6和Frame19的N的因子p分别为[920724637201,1085663496559]
    ===破解代码为Pollard_rho.py
    ===解出Frame6明文为   m = ' "Logic '
           Frame19明文为  m = 'instein.'

    ===目前破解的Frame有0,1,3,4,6,8,12,16,18,19,20

六、在p，q的取值差异过大，或者p，q的取值过于相近的时候，利用yafu可以较快分解出n(yafu包含Pollard rho算法)

    ===解出Frame2明文为   m = ' That is'

    ===目前破解的Frame有0,1,2,3,4,6,8,10,12,16,18,19,20